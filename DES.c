#define _CRT_SECURE_NO_WARNINGS_
#include <stdio.h>

typedef unsigned char BYTE;
typedef unsigned int UINT;
BYTE S_BOX[8][4][64] = { 
					{{14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7}, //S1
					{0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8},
					{4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0},
					{15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 2, 14, 10, 0, 6, 13}},

			{{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10}, //S2
			 {3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5},
			 {0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15},
			 {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}},

			{{10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8}, //S3
			 {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},
			 {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7},
			 {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}},

			{{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},
			 {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9}, //S4
			 {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},
			 {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}},

			{{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},
			 {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6}, //S5
			 {4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},
			 {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}},

			{{4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1},
			 {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},	//S6
			 {1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},
			 {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}},

			{{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},
			 {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},	//S7
			 {9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},
			 {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}},

			{{13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},
			 {1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2},
			 {7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8},	//S8
			 {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}} };



BYTE E[48] = { 32, 1, 2, 3, 4, 5,
   4, 5, 6, 7, 8, 9,
   8, 9, 10, 11, 12, 13,
   12, 13, 14, 15, 16, 17,
   16, 17, 18, 19, 20, 21,
   20, 21, 22, 23, 24, 25,
   24, 25, 26, 27, 28, 29,
   28, 29, 30, 31, 32, 1 };  //확장 테이블

BYTE KEY_L[28] = { 49,42,35,28,21,14,
				7,0,50,43,36,29,22,15,
				8,1,51,44,37,30,23,16
				,9,2,52,45,38,31 };   //키 왼쪽 확장
BYTE KEY_R[28] = { 55,48,41,34,27,20,13,6,
				54,47,40,33,26,19,12,5,
				53,46,39,32,25,18,11,4,
				24,17,10,3 };   //키 오른쪽 확장

BYTE PC[48] = { 14,  17,  11,  24,   1,   5,
				3,  28,  15,   6,  21,  10,
				23,  19,  12,   4,  26,   8,
				16,   7,  27,  20,  13,   2,
				41,  52,  31,  37,  47,  55,
				30,  40,  51,  45,  33,  48,
				44,  49,  39,  56,  34,  53,
				46,  42,  50,  36,  29,  32 }; //COMPRESS TABLE.


BYTE ip[64] = { 58, 50, 42, 34, 26, 18, 10, 2,
			60, 52, 44, 36, 28, 20, 12, 4,
			62, 54, 46, 38, 30, 22, 14, 6,
			64, 56, 48, 40, 32, 24, 16, 8,
			57, 49, 41, 33, 25, 17, 9, 1,
			59, 51, 43, 35, 27, 19, 11, 3,
			61, 53, 45, 37, 29, 21, 13, 5,
			63, 55, 47, 39, 31, 23, 15, 7 }; //초기 전치 테이블

BYTE olddata[64] = { 0,0,0,0,0,0,0,1,
				0,0,1,0,0,0,1,1,
				0,1,0,0,0,1,0,1,
				0,1,1,0,0,1,1,1,
				1,0,0,0,1,0,0,1,
				1,0,1,0,1,0,1,1,
				1,1,0,0,1,1,0,1,
				1,1,1,0,1,1,1,1 }; //입력값

BYTE newdata[64] = { 0 };
BYTE L[32] = { 0 };
BYTE R[32] = { 0 };
BYTE EXPAND_R[48] = { 0 }; //R의 확장 
BYTE key_L[28] = { 0 }; //키의 왼쪽 
BYTE key_R[28] = { 0 }; //키의 오른쪽 
BYTE COMPRESS_KEY[16][48] = { 0 };
BYTE LtoR_KEY[56] = { 0 }; //왼쪽과 오른쪽 shift 하는 것을 합친 것
BYTE AFTER_SBOX[32] = { 0 };


BYTE KEY[56] = { 0,0,0,0,0,0,0,0, //0
			  0,0,0,1,0,0,0,1, //1
			  0,0,1,0,0,0,1,0, //2 
			  0,0,1,1,0,0,1,1, //3
			  0,1,0,0,0,1,0,0, //4
			  0,1,0,1,0,1,0,1, //5
			  0,1,1,0,0,1,1,0, //6
			  };   //입력하려는 키 값 

			
void IP(BYTE *olddata, BYTE *newdata); //전치 함수

void IP(BYTE *olddata, BYTE *newdata) //전치 함수
{
	int i;

	for (i = 0; i < 64; i++)
	{
		newdata[i] = olddata[ip[i] - 1]; //newdata 초기전치값
	}
}

int main() {

	int t=0;
	IP(olddata, newdata);
	int count = 0;
	printf("result :");
	for (int i = 0; i < 64; i++)
	{
		if (count % 4 == 0) {
			printf(" ");

		}

		printf("%d", newdata[i]);
		count++;
	} // 전치값

	printf("\n");
	printf("KEY :");
	for (int i = 0; i < 56; i++)
	{
		printf("%d", KEY[i]);
	}
	printf("\n");

	//입력값을 절반으로 L R로 나누기
	for (int i = 0; i < 32; i++) {
			if (count %4 == 0) {
				printf(" ");
				
			}
			L[i] = newdata[i];
			printf("%d", L[i]);
			count++;
			
	}
	printf("\n");

	for (int i = 32; i < 64; i++) {
		if (count % 4 == 0) {
			printf(" ");

		}
		R[i-32] = newdata[i];
		printf("%d", R[i-32]);
		count++;
	}
	printf("\n");

	//키가 아닌 입력값을 좌우로 나눈 것에서 R값 expand 
	printf("expand R:  ");
	for (int i = 0; i < 48; i++) {

		EXPAND_R[i] = R[E[i]- 1];

	}
	

	for (int i = 0; i < 48; i++) {
		if (count % 4 == 0) {
			printf(" ");

		}
		printf("%d", EXPAND_R[i]);
		count++;
	}

	printf("\n");
	printf(" key ------------------------------------------\n");

	for (int i = 0; i < 28; i++) {
		key_L[i] = KEY[KEY_L[i]];
		if (count % 4 == 0) {
			printf(" ");

		}
		printf("%d", key_L[i]); //KEY의 왼쪽
		count++;
	}
	printf("\n");


	for (int i = 0; i < 28; i++) {
		key_R[i] = KEY[KEY_R[i]];
		if (count % 4 == 0) {
			printf(" ");

		}
 		printf("%d", key_R[i]); //KEY의 오른쪽 
		count++;
	}
	printf("\n");

	
	
	//DES 보조키 ROUND 1 2 9 16 일때

	for (int j = 0; j < 16; j++) {
		
		if (j == 0 || j == 1 || j == 8 || j == 15) {  //round 1 0,1,8,15일때
			
			t = key_L[0];
			for (int i = 0; i < 27; i++) {
				key_L[i] = key_L[i + 1];

			}
			 key_L[27]=t;

			t = key_R[0];
			for (int i = 0; i < 27; i++) {
				key_R[i] = key_R[i + 1];

			}
			key_R[27]=t;
			
			printf("\n");
			
			
			for (int i = 0; i < 28; i++) {
				LtoR_KEY[i] = key_L[i];
				LtoR_KEY[i + 28] = key_R[i];  //왼쪽 오른쪽 합침 
				//printf("%d", LtoR_KEY[i]);
			}


			for (int i = 0; i < 48; i++) {
				COMPRESS_KEY[j][i] = LtoR_KEY[PC[i]-1]; 
			}

		}
		else
			for (int k = 0; k < 2; k++) {

				t=key_L[0] ;
				for (int i = 0; i < 27; i++) {
					key_L[i] = key_L[i + 1];

				}
				 key_L[27]=t;

				t= key_R[0];
				for (int i = 0; i < 27; i++) {
					key_R[i] = key_R[i + 1];

				}
				key_R[27]=t;

				for (int i = 0; i < 28; i++) {
					LtoR_KEY[i] = key_L[i];
					LtoR_KEY[i + 28] = key_R[i];  //왼쪽 오른쪽 합침 
				}

				for (int i = 0; i < 48; i++) {
					COMPRESS_KEY[j][i] = LtoR_KEY[PC[i]];
				}

			}


	}

	printf("\n");
	//K1..K2....K3...K4...

	for (int j = 0; j < 16; j++) {
		printf("K %d: ", j+1);
		for (int k = 0; k < 48; k++) {
			if (count % 4 == 0) {
				printf(" ");

			}
			printf("%d", COMPRESS_KEY[j][k]);
			count++;
			
		}printf("\n");
	}

	//----------------------KEY 완료 이제 xor 해야함------------------
	printf("-------------round 1 XOR--------------\n");
	
	
	//EXPAND 와 K를 XOR 하기 
		count = 0;
		for (int k = 0; k < 48; k++) {
			
			EXPAND_R[k] = EXPAND_R[k] ^ COMPRESS_KEY[0][k];
			if (count % 6 == 0) {
				printf(" ");

			}
			printf("%d",EXPAND_R[k]);
			count++;
		}
		printf("\n");
		printf("-------------sbox--------------\n");
		
	//EXPAND R과 SBOX를 전치시키기 48-->32
		
		

	//	}



		//고귀양이코드
		/*int i, row, column, shift = 28;
		UINT temp = 0, result = 0, mask = 0x80;
		count = 0;
		for (i = 0; i <16; i++)
		{
			
			if (EXPAND_R[i / 8] & (BYTE)(mask >> (i % 8)))  // 마스크를 씌워 확인 후 temp에 해당 비트 1로 함
				temp |= 0x20 >> (i % 6);

			if ((i + 1) % 6 == 0)                        // 6비트마다
			{
			
				row =  (temp & 0x01)+ ((temp & 0x20) >> 4);           // 행 값
				column = (temp & 0x1E) >> 1;            // 열 값
			

				result += (S_BOX[i/6][row][column] << shift);    // 값 더하고 쉬프트(4비트씩)

				shift -= 4;
				temp = 0;
				//printf("row: %d col :%d", row, column);
			}
			
			if (count % 4 == 0) {
				printf(" ");

			}
			
			printf("%d", EXPAND_R[i]);
			count++;
		}*/
		
	


	


	

	getch();
}